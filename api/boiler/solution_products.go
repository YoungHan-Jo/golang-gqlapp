// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SolutionProduct is an object representing the database table.
type SolutionProduct struct { // ソリューションプロダクトID
	ID []byte `boil:"id" json:"id" toml:"id" yaml:"id"`
	// ソリューションマスタID
	SolutionMasterID []byte `boil:"solution_master_id" json:"solution_master_id" toml:"solution_master_id" yaml:"solution_master_id"`
	// ソリューションプロダクト名
	ProductName string `boil:"product_name" json:"product_name" toml:"product_name" yaml:"product_name"`
	// 企業名
	ComapanyName null.String `boil:"comapany_name" json:"comapany_name,omitempty" toml:"comapany_name" yaml:"comapany_name,omitempty"`
	// 企業URL
	ComapanyURL null.String `boil:"comapany_url" json:"comapany_url,omitempty" toml:"comapany_url" yaml:"comapany_url,omitempty"`
	// 初期費用
	InitialPrice null.Int `boil:"initial_price" json:"initial_price,omitempty" toml:"initial_price" yaml:"initial_price,omitempty"`
	// 月額費用
	PricePerMonth null.Int `boil:"price_per_month" json:"price_per_month,omitempty" toml:"price_per_month" yaml:"price_per_month,omitempty"`
	// アカウントあたりの費用
	PricePerAccount null.Int `boil:"price_per_account" json:"price_per_account,omitempty" toml:"price_per_account" yaml:"price_per_account,omitempty"`
	// 備考
	Remark null.String `boil:"remark" json:"remark,omitempty" toml:"remark" yaml:"remark,omitempty"`
	// 更新企業
	UpdatedCompany null.String `boil:"updated_company" json:"updated_company,omitempty" toml:"updated_company" yaml:"updated_company,omitempty"`
	// 更新担当者
	UpdatedStaff null.String `boil:"updated_staff" json:"updated_staff,omitempty" toml:"updated_staff" yaml:"updated_staff,omitempty"`
	// 企業担当者
	CompanyStaff null.String `boil:"company_staff" json:"company_staff,omitempty" toml:"company_staff" yaml:"company_staff,omitempty"`
	// 企業担当者メールアドレス
	CompanyStaffEmail string `boil:"company_staff_email" json:"company_staff_email" toml:"company_staff_email" yaml:"company_staff_email"`
	// 特徴
	Feature null.String `boil:"feature" json:"feature,omitempty" toml:"feature" yaml:"feature,omitempty"`
	// データ作成日
	CreatedAt time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	// データ更新日
	UpdatedAt time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *solutionProductR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L solutionProductL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SolutionProductColumns = struct {
	ID                string
	SolutionMasterID  string
	ProductName       string
	ComapanyName      string
	ComapanyURL       string
	InitialPrice      string
	PricePerMonth     string
	PricePerAccount   string
	Remark            string
	UpdatedCompany    string
	UpdatedStaff      string
	CompanyStaff      string
	CompanyStaffEmail string
	Feature           string
	CreatedAt         string
	UpdatedAt         string
}{
	ID:                "id",
	SolutionMasterID:  "solution_master_id",
	ProductName:       "product_name",
	ComapanyName:      "comapany_name",
	ComapanyURL:       "comapany_url",
	InitialPrice:      "initial_price",
	PricePerMonth:     "price_per_month",
	PricePerAccount:   "price_per_account",
	Remark:            "remark",
	UpdatedCompany:    "updated_company",
	UpdatedStaff:      "updated_staff",
	CompanyStaff:      "company_staff",
	CompanyStaffEmail: "company_staff_email",
	Feature:           "feature",
	CreatedAt:         "created_at",
	UpdatedAt:         "updated_at",
}

var SolutionProductTableColumns = struct {
	ID                string
	SolutionMasterID  string
	ProductName       string
	ComapanyName      string
	ComapanyURL       string
	InitialPrice      string
	PricePerMonth     string
	PricePerAccount   string
	Remark            string
	UpdatedCompany    string
	UpdatedStaff      string
	CompanyStaff      string
	CompanyStaffEmail string
	Feature           string
	CreatedAt         string
	UpdatedAt         string
}{
	ID:                "solution_products.id",
	SolutionMasterID:  "solution_products.solution_master_id",
	ProductName:       "solution_products.product_name",
	ComapanyName:      "solution_products.comapany_name",
	ComapanyURL:       "solution_products.comapany_url",
	InitialPrice:      "solution_products.initial_price",
	PricePerMonth:     "solution_products.price_per_month",
	PricePerAccount:   "solution_products.price_per_account",
	Remark:            "solution_products.remark",
	UpdatedCompany:    "solution_products.updated_company",
	UpdatedStaff:      "solution_products.updated_staff",
	CompanyStaff:      "solution_products.company_staff",
	CompanyStaffEmail: "solution_products.company_staff_email",
	Feature:           "solution_products.feature",
	CreatedAt:         "solution_products.created_at",
	UpdatedAt:         "solution_products.updated_at",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var SolutionProductWhere = struct {
	ID                whereHelper__byte
	SolutionMasterID  whereHelper__byte
	ProductName       whereHelperstring
	ComapanyName      whereHelpernull_String
	ComapanyURL       whereHelpernull_String
	InitialPrice      whereHelpernull_Int
	PricePerMonth     whereHelpernull_Int
	PricePerAccount   whereHelpernull_Int
	Remark            whereHelpernull_String
	UpdatedCompany    whereHelpernull_String
	UpdatedStaff      whereHelpernull_String
	CompanyStaff      whereHelpernull_String
	CompanyStaffEmail whereHelperstring
	Feature           whereHelpernull_String
	CreatedAt         whereHelpertime_Time
	UpdatedAt         whereHelpertime_Time
}{
	ID:                whereHelper__byte{field: "\"solution_products\".\"id\""},
	SolutionMasterID:  whereHelper__byte{field: "\"solution_products\".\"solution_master_id\""},
	ProductName:       whereHelperstring{field: "\"solution_products\".\"product_name\""},
	ComapanyName:      whereHelpernull_String{field: "\"solution_products\".\"comapany_name\""},
	ComapanyURL:       whereHelpernull_String{field: "\"solution_products\".\"comapany_url\""},
	InitialPrice:      whereHelpernull_Int{field: "\"solution_products\".\"initial_price\""},
	PricePerMonth:     whereHelpernull_Int{field: "\"solution_products\".\"price_per_month\""},
	PricePerAccount:   whereHelpernull_Int{field: "\"solution_products\".\"price_per_account\""},
	Remark:            whereHelpernull_String{field: "\"solution_products\".\"remark\""},
	UpdatedCompany:    whereHelpernull_String{field: "\"solution_products\".\"updated_company\""},
	UpdatedStaff:      whereHelpernull_String{field: "\"solution_products\".\"updated_staff\""},
	CompanyStaff:      whereHelpernull_String{field: "\"solution_products\".\"company_staff\""},
	CompanyStaffEmail: whereHelperstring{field: "\"solution_products\".\"company_staff_email\""},
	Feature:           whereHelpernull_String{field: "\"solution_products\".\"feature\""},
	CreatedAt:         whereHelpertime_Time{field: "\"solution_products\".\"created_at\""},
	UpdatedAt:         whereHelpertime_Time{field: "\"solution_products\".\"updated_at\""},
}

// SolutionProductRels is where relationship names are stored.
var SolutionProductRels = struct {
	SolutionMaster                        string
	SolutionComplaintHandlingProduct      string
	SolutionConstructionManagementProduct string
	SolutionCostControlProduct            string
	SolutionKpiManagementProduct          string
	SolutionOcrProduct                    string
	SolutionPackagingProduct              string
	SolutionSaasManagementProduct         string
	SolutionSaasResearchProduct           string
	SolutionWMSProduct                    string
}{
	SolutionMaster:                        "SolutionMaster",
	SolutionComplaintHandlingProduct:      "SolutionComplaintHandlingProduct",
	SolutionConstructionManagementProduct: "SolutionConstructionManagementProduct",
	SolutionCostControlProduct:            "SolutionCostControlProduct",
	SolutionKpiManagementProduct:          "SolutionKpiManagementProduct",
	SolutionOcrProduct:                    "SolutionOcrProduct",
	SolutionPackagingProduct:              "SolutionPackagingProduct",
	SolutionSaasManagementProduct:         "SolutionSaasManagementProduct",
	SolutionSaasResearchProduct:           "SolutionSaasResearchProduct",
	SolutionWMSProduct:                    "SolutionWMSProduct",
}

// solutionProductR is where relationships are stored.
type solutionProductR struct {
	SolutionMaster                        *SolutionMaster                        `boil:"SolutionMaster" json:"SolutionMaster" toml:"SolutionMaster" yaml:"SolutionMaster"`
	SolutionComplaintHandlingProduct      *SolutionComplaintHandlingProduct      `boil:"SolutionComplaintHandlingProduct" json:"SolutionComplaintHandlingProduct" toml:"SolutionComplaintHandlingProduct" yaml:"SolutionComplaintHandlingProduct"`
	SolutionConstructionManagementProduct *SolutionConstructionManagementProduct `boil:"SolutionConstructionManagementProduct" json:"SolutionConstructionManagementProduct" toml:"SolutionConstructionManagementProduct" yaml:"SolutionConstructionManagementProduct"`
	SolutionCostControlProduct            *SolutionCostControlProduct            `boil:"SolutionCostControlProduct" json:"SolutionCostControlProduct" toml:"SolutionCostControlProduct" yaml:"SolutionCostControlProduct"`
	SolutionKpiManagementProduct          *SolutionKpiManagementProduct          `boil:"SolutionKpiManagementProduct" json:"SolutionKpiManagementProduct" toml:"SolutionKpiManagementProduct" yaml:"SolutionKpiManagementProduct"`
	SolutionOcrProduct                    *SolutionOcrProduct                    `boil:"SolutionOcrProduct" json:"SolutionOcrProduct" toml:"SolutionOcrProduct" yaml:"SolutionOcrProduct"`
	SolutionPackagingProduct              *SolutionPackagingProduct              `boil:"SolutionPackagingProduct" json:"SolutionPackagingProduct" toml:"SolutionPackagingProduct" yaml:"SolutionPackagingProduct"`
	SolutionSaasManagementProduct         *SolutionSaasManagementProduct         `boil:"SolutionSaasManagementProduct" json:"SolutionSaasManagementProduct" toml:"SolutionSaasManagementProduct" yaml:"SolutionSaasManagementProduct"`
	SolutionSaasResearchProduct           *SolutionSaasResearchProduct           `boil:"SolutionSaasResearchProduct" json:"SolutionSaasResearchProduct" toml:"SolutionSaasResearchProduct" yaml:"SolutionSaasResearchProduct"`
	SolutionWMSProduct                    *SolutionWMSProduct                    `boil:"SolutionWMSProduct" json:"SolutionWMSProduct" toml:"SolutionWMSProduct" yaml:"SolutionWMSProduct"`
}

// NewStruct creates a new relationship struct
func (*solutionProductR) NewStruct() *solutionProductR {
	return &solutionProductR{}
}

func (r *solutionProductR) GetSolutionMaster() *SolutionMaster {
	if r == nil {
		return nil
	}
	return r.SolutionMaster
}

func (r *solutionProductR) GetSolutionComplaintHandlingProduct() *SolutionComplaintHandlingProduct {
	if r == nil {
		return nil
	}
	return r.SolutionComplaintHandlingProduct
}

func (r *solutionProductR) GetSolutionConstructionManagementProduct() *SolutionConstructionManagementProduct {
	if r == nil {
		return nil
	}
	return r.SolutionConstructionManagementProduct
}

func (r *solutionProductR) GetSolutionCostControlProduct() *SolutionCostControlProduct {
	if r == nil {
		return nil
	}
	return r.SolutionCostControlProduct
}

func (r *solutionProductR) GetSolutionKpiManagementProduct() *SolutionKpiManagementProduct {
	if r == nil {
		return nil
	}
	return r.SolutionKpiManagementProduct
}

func (r *solutionProductR) GetSolutionOcrProduct() *SolutionOcrProduct {
	if r == nil {
		return nil
	}
	return r.SolutionOcrProduct
}

func (r *solutionProductR) GetSolutionPackagingProduct() *SolutionPackagingProduct {
	if r == nil {
		return nil
	}
	return r.SolutionPackagingProduct
}

func (r *solutionProductR) GetSolutionSaasManagementProduct() *SolutionSaasManagementProduct {
	if r == nil {
		return nil
	}
	return r.SolutionSaasManagementProduct
}

func (r *solutionProductR) GetSolutionSaasResearchProduct() *SolutionSaasResearchProduct {
	if r == nil {
		return nil
	}
	return r.SolutionSaasResearchProduct
}

func (r *solutionProductR) GetSolutionWMSProduct() *SolutionWMSProduct {
	if r == nil {
		return nil
	}
	return r.SolutionWMSProduct
}

// solutionProductL is where Load methods for each relationship are stored.
type solutionProductL struct{}

var (
	solutionProductAllColumns            = []string{"id", "solution_master_id", "product_name", "comapany_name", "comapany_url", "initial_price", "price_per_month", "price_per_account", "remark", "updated_company", "updated_staff", "company_staff", "company_staff_email", "feature", "created_at", "updated_at"}
	solutionProductColumnsWithoutDefault = []string{"solution_master_id", "product_name", "company_staff_email"}
	solutionProductColumnsWithDefault    = []string{"id", "comapany_name", "comapany_url", "initial_price", "price_per_month", "price_per_account", "remark", "updated_company", "updated_staff", "company_staff", "feature", "created_at", "updated_at"}
	solutionProductPrimaryKeyColumns     = []string{"id"}
	solutionProductGeneratedColumns      = []string{}
)

type (
	// SolutionProductSlice is an alias for a slice of pointers to SolutionProduct.
	// This should almost always be used instead of []SolutionProduct.
	SolutionProductSlice []*SolutionProduct
	// SolutionProductHook is the signature for custom SolutionProduct hook methods
	SolutionProductHook func(context.Context, boil.ContextExecutor, *SolutionProduct) error

	solutionProductQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	solutionProductType                 = reflect.TypeOf(&SolutionProduct{})
	solutionProductMapping              = queries.MakeStructMapping(solutionProductType)
	solutionProductPrimaryKeyMapping, _ = queries.BindMapping(solutionProductType, solutionProductMapping, solutionProductPrimaryKeyColumns)
	solutionProductInsertCacheMut       sync.RWMutex
	solutionProductInsertCache          = make(map[string]insertCache)
	solutionProductUpdateCacheMut       sync.RWMutex
	solutionProductUpdateCache          = make(map[string]updateCache)
	solutionProductUpsertCacheMut       sync.RWMutex
	solutionProductUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var solutionProductAfterSelectHooks []SolutionProductHook

var solutionProductBeforeInsertHooks []SolutionProductHook
var solutionProductAfterInsertHooks []SolutionProductHook

var solutionProductBeforeUpdateHooks []SolutionProductHook
var solutionProductAfterUpdateHooks []SolutionProductHook

var solutionProductBeforeDeleteHooks []SolutionProductHook
var solutionProductAfterDeleteHooks []SolutionProductHook

var solutionProductBeforeUpsertHooks []SolutionProductHook
var solutionProductAfterUpsertHooks []SolutionProductHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SolutionProduct) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SolutionProduct) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SolutionProduct) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SolutionProduct) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SolutionProduct) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SolutionProduct) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SolutionProduct) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SolutionProduct) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SolutionProduct) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range solutionProductAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSolutionProductHook registers your hook function for all future operations.
func AddSolutionProductHook(hookPoint boil.HookPoint, solutionProductHook SolutionProductHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		solutionProductAfterSelectHooks = append(solutionProductAfterSelectHooks, solutionProductHook)
	case boil.BeforeInsertHook:
		solutionProductBeforeInsertHooks = append(solutionProductBeforeInsertHooks, solutionProductHook)
	case boil.AfterInsertHook:
		solutionProductAfterInsertHooks = append(solutionProductAfterInsertHooks, solutionProductHook)
	case boil.BeforeUpdateHook:
		solutionProductBeforeUpdateHooks = append(solutionProductBeforeUpdateHooks, solutionProductHook)
	case boil.AfterUpdateHook:
		solutionProductAfterUpdateHooks = append(solutionProductAfterUpdateHooks, solutionProductHook)
	case boil.BeforeDeleteHook:
		solutionProductBeforeDeleteHooks = append(solutionProductBeforeDeleteHooks, solutionProductHook)
	case boil.AfterDeleteHook:
		solutionProductAfterDeleteHooks = append(solutionProductAfterDeleteHooks, solutionProductHook)
	case boil.BeforeUpsertHook:
		solutionProductBeforeUpsertHooks = append(solutionProductBeforeUpsertHooks, solutionProductHook)
	case boil.AfterUpsertHook:
		solutionProductAfterUpsertHooks = append(solutionProductAfterUpsertHooks, solutionProductHook)
	}
}

// One returns a single solutionProduct record from the query.
func (q solutionProductQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SolutionProduct, error) {
	o := &SolutionProduct{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for solution_products")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SolutionProduct records from the query.
func (q solutionProductQuery) All(ctx context.Context, exec boil.ContextExecutor) (SolutionProductSlice, error) {
	var o []*SolutionProduct

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to SolutionProduct slice")
	}

	if len(solutionProductAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SolutionProduct records in the query.
func (q solutionProductQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count solution_products rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q solutionProductQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if solution_products exists")
	}

	return count > 0, nil
}

// SolutionMaster pointed to by the foreign key.
func (o *SolutionProduct) SolutionMaster(mods ...qm.QueryMod) solutionMasterQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SolutionMasterID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionMasters(queryMods...)
}

// SolutionComplaintHandlingProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionComplaintHandlingProduct(mods ...qm.QueryMod) solutionComplaintHandlingProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionComplaintHandlingProducts(queryMods...)
}

// SolutionConstructionManagementProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionConstructionManagementProduct(mods ...qm.QueryMod) solutionConstructionManagementProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionConstructionManagementProducts(queryMods...)
}

// SolutionCostControlProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionCostControlProduct(mods ...qm.QueryMod) solutionCostControlProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionCostControlProducts(queryMods...)
}

// SolutionKpiManagementProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionKpiManagementProduct(mods ...qm.QueryMod) solutionKpiManagementProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionKpiManagementProducts(queryMods...)
}

// SolutionOcrProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionOcrProduct(mods ...qm.QueryMod) solutionOcrProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionOcrProducts(queryMods...)
}

// SolutionPackagingProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionPackagingProduct(mods ...qm.QueryMod) solutionPackagingProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionPackagingProducts(queryMods...)
}

// SolutionSaasManagementProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionSaasManagementProduct(mods ...qm.QueryMod) solutionSaasManagementProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionSaasManagementProducts(queryMods...)
}

// SolutionSaasResearchProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionSaasResearchProduct(mods ...qm.QueryMod) solutionSaasResearchProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionSaasResearchProducts(queryMods...)
}

// SolutionWMSProduct pointed to by the foreign key.
func (o *SolutionProduct) SolutionWMSProduct(mods ...qm.QueryMod) solutionWMSProductQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"solution_product_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return SolutionWMSProducts(queryMods...)
}

// LoadSolutionMaster allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (solutionProductL) LoadSolutionMaster(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		if !queries.IsNil(object.SolutionMasterID) {
			args = append(args, object.SolutionMasterID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SolutionMasterID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SolutionMasterID) {
				args = append(args, obj.SolutionMasterID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_masters`),
		qm.WhereIn(`solution_masters.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionMaster")
	}

	var resultSlice []*SolutionMaster
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionMaster")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_masters")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_masters")
	}

	if len(solutionMasterAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionMaster = foreign
		if foreign.R == nil {
			foreign.R = &solutionMasterR{}
		}
		foreign.R.SolutionProducts = append(foreign.R.SolutionProducts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SolutionMasterID, foreign.ID) {
				local.R.SolutionMaster = foreign
				if foreign.R == nil {
					foreign.R = &solutionMasterR{}
				}
				foreign.R.SolutionProducts = append(foreign.R.SolutionProducts, local)
				break
			}
		}
	}

	return nil
}

// LoadSolutionComplaintHandlingProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionComplaintHandlingProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_complaint_handling_products`),
		qm.WhereIn(`solution_complaint_handling_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionComplaintHandlingProduct")
	}

	var resultSlice []*SolutionComplaintHandlingProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionComplaintHandlingProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_complaint_handling_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_complaint_handling_products")
	}

	if len(solutionComplaintHandlingProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionComplaintHandlingProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionComplaintHandlingProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionComplaintHandlingProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionComplaintHandlingProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionConstructionManagementProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionConstructionManagementProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_construction_management_products`),
		qm.WhereIn(`solution_construction_management_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionConstructionManagementProduct")
	}

	var resultSlice []*SolutionConstructionManagementProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionConstructionManagementProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_construction_management_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_construction_management_products")
	}

	if len(solutionConstructionManagementProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionConstructionManagementProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionConstructionManagementProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionConstructionManagementProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionConstructionManagementProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionCostControlProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionCostControlProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_cost_control_products`),
		qm.WhereIn(`solution_cost_control_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionCostControlProduct")
	}

	var resultSlice []*SolutionCostControlProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionCostControlProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_cost_control_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_cost_control_products")
	}

	if len(solutionCostControlProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionCostControlProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionCostControlProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionCostControlProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionCostControlProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionKpiManagementProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionKpiManagementProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_kpi_management_products`),
		qm.WhereIn(`solution_kpi_management_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionKpiManagementProduct")
	}

	var resultSlice []*SolutionKpiManagementProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionKpiManagementProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_kpi_management_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_kpi_management_products")
	}

	if len(solutionKpiManagementProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionKpiManagementProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionKpiManagementProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionKpiManagementProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionKpiManagementProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionOcrProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionOcrProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_ocr_products`),
		qm.WhereIn(`solution_ocr_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionOcrProduct")
	}

	var resultSlice []*SolutionOcrProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionOcrProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_ocr_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_ocr_products")
	}

	if len(solutionOcrProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionOcrProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionOcrProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionOcrProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionOcrProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionPackagingProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionPackagingProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_packaging_products`),
		qm.WhereIn(`solution_packaging_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionPackagingProduct")
	}

	var resultSlice []*SolutionPackagingProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionPackagingProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_packaging_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_packaging_products")
	}

	if len(solutionPackagingProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionPackagingProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionPackagingProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionPackagingProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionPackagingProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionSaasManagementProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionSaasManagementProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_saas_management_products`),
		qm.WhereIn(`solution_saas_management_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionSaasManagementProduct")
	}

	var resultSlice []*SolutionSaasManagementProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionSaasManagementProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_saas_management_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_saas_management_products")
	}

	if len(solutionSaasManagementProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionSaasManagementProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionSaasManagementProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionSaasManagementProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionSaasManagementProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionSaasResearchProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionSaasResearchProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_saas_research_products`),
		qm.WhereIn(`solution_saas_research_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionSaasResearchProduct")
	}

	var resultSlice []*SolutionSaasResearchProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionSaasResearchProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_saas_research_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_saas_research_products")
	}

	if len(solutionSaasResearchProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionSaasResearchProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionSaasResearchProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionSaasResearchProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionSaasResearchProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// LoadSolutionWMSProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (solutionProductL) LoadSolutionWMSProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSolutionProduct interface{}, mods queries.Applicator) error {
	var slice []*SolutionProduct
	var object *SolutionProduct

	if singular {
		var ok bool
		object, ok = maybeSolutionProduct.(*SolutionProduct)
		if !ok {
			object = new(SolutionProduct)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeSolutionProduct))
			}
		}
	} else {
		s, ok := maybeSolutionProduct.(*[]*SolutionProduct)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeSolutionProduct)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeSolutionProduct))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &solutionProductR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &solutionProductR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`solution_wms_products`),
		qm.WhereIn(`solution_wms_products.solution_product_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SolutionWMSProduct")
	}

	var resultSlice []*SolutionWMSProduct
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SolutionWMSProduct")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for solution_wms_products")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for solution_wms_products")
	}

	if len(solutionWMSProductAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SolutionWMSProduct = foreign
		if foreign.R == nil {
			foreign.R = &solutionWMSProductR{}
		}
		foreign.R.SolutionProduct = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ID, foreign.SolutionProductID) {
				local.R.SolutionWMSProduct = foreign
				if foreign.R == nil {
					foreign.R = &solutionWMSProductR{}
				}
				foreign.R.SolutionProduct = local
				break
			}
		}
	}

	return nil
}

// SetSolutionMaster of the solutionProduct to the related item.
// Sets o.R.SolutionMaster to related.
// Adds o to related.R.SolutionProducts.
func (o *SolutionProduct) SetSolutionMaster(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionMaster) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"solution_products\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"solution_master_id"}),
		strmangle.WhereClause("\"", "\"", 2, solutionProductPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SolutionMasterID, related.ID)
	if o.R == nil {
		o.R = &solutionProductR{
			SolutionMaster: related,
		}
	} else {
		o.R.SolutionMaster = related
	}

	if related.R == nil {
		related.R = &solutionMasterR{
			SolutionProducts: SolutionProductSlice{o},
		}
	} else {
		related.R.SolutionProducts = append(related.R.SolutionProducts, o)
	}

	return nil
}

// SetSolutionComplaintHandlingProduct of the solutionProduct to the related item.
// Sets o.R.SolutionComplaintHandlingProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionComplaintHandlingProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionComplaintHandlingProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_complaint_handling_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionComplaintHandlingProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionComplaintHandlingProduct: related,
		}
	} else {
		o.R.SolutionComplaintHandlingProduct = related
	}

	if related.R == nil {
		related.R = &solutionComplaintHandlingProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionConstructionManagementProduct of the solutionProduct to the related item.
// Sets o.R.SolutionConstructionManagementProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionConstructionManagementProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionConstructionManagementProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_construction_management_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionConstructionManagementProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionConstructionManagementProduct: related,
		}
	} else {
		o.R.SolutionConstructionManagementProduct = related
	}

	if related.R == nil {
		related.R = &solutionConstructionManagementProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionCostControlProduct of the solutionProduct to the related item.
// Sets o.R.SolutionCostControlProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionCostControlProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionCostControlProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_cost_control_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionCostControlProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionCostControlProduct: related,
		}
	} else {
		o.R.SolutionCostControlProduct = related
	}

	if related.R == nil {
		related.R = &solutionCostControlProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionKpiManagementProduct of the solutionProduct to the related item.
// Sets o.R.SolutionKpiManagementProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionKpiManagementProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionKpiManagementProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_kpi_management_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionKpiManagementProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionKpiManagementProduct: related,
		}
	} else {
		o.R.SolutionKpiManagementProduct = related
	}

	if related.R == nil {
		related.R = &solutionKpiManagementProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionOcrProduct of the solutionProduct to the related item.
// Sets o.R.SolutionOcrProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionOcrProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionOcrProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_ocr_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionOcrProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionOcrProduct: related,
		}
	} else {
		o.R.SolutionOcrProduct = related
	}

	if related.R == nil {
		related.R = &solutionOcrProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionPackagingProduct of the solutionProduct to the related item.
// Sets o.R.SolutionPackagingProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionPackagingProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionPackagingProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_packaging_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionPackagingProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionPackagingProduct: related,
		}
	} else {
		o.R.SolutionPackagingProduct = related
	}

	if related.R == nil {
		related.R = &solutionPackagingProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionSaasManagementProduct of the solutionProduct to the related item.
// Sets o.R.SolutionSaasManagementProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionSaasManagementProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionSaasManagementProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_saas_management_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionSaasManagementProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionSaasManagementProduct: related,
		}
	} else {
		o.R.SolutionSaasManagementProduct = related
	}

	if related.R == nil {
		related.R = &solutionSaasManagementProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionSaasResearchProduct of the solutionProduct to the related item.
// Sets o.R.SolutionSaasResearchProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionSaasResearchProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionSaasResearchProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_saas_research_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionSaasResearchProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionSaasResearchProduct: related,
		}
	} else {
		o.R.SolutionSaasResearchProduct = related
	}

	if related.R == nil {
		related.R = &solutionSaasResearchProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SetSolutionWMSProduct of the solutionProduct to the related item.
// Sets o.R.SolutionWMSProduct to related.
// Adds o to related.R.SolutionProduct.
func (o *SolutionProduct) SetSolutionWMSProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SolutionWMSProduct) error {
	var err error

	if insert {
		queries.Assign(&related.SolutionProductID, o.ID)

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"solution_wms_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"solution_product_id"}),
			strmangle.WhereClause("\"", "\"", 2, solutionWMSProductPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		queries.Assign(&related.SolutionProductID, o.ID)
	}

	if o.R == nil {
		o.R = &solutionProductR{
			SolutionWMSProduct: related,
		}
	} else {
		o.R.SolutionWMSProduct = related
	}

	if related.R == nil {
		related.R = &solutionWMSProductR{
			SolutionProduct: o,
		}
	} else {
		related.R.SolutionProduct = o
	}
	return nil
}

// SolutionProducts retrieves all the records using an executor.
func SolutionProducts(mods ...qm.QueryMod) solutionProductQuery {
	mods = append(mods, qm.From("\"solution_products\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"solution_products\".*"})
	}

	return solutionProductQuery{q}
}

// FindSolutionProduct retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSolutionProduct(ctx context.Context, exec boil.ContextExecutor, iD []byte, selectCols ...string) (*SolutionProduct, error) {
	solutionProductObj := &SolutionProduct{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"solution_products\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, solutionProductObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from solution_products")
	}

	if err = solutionProductObj.doAfterSelectHooks(ctx, exec); err != nil {
		return solutionProductObj, err
	}

	return solutionProductObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SolutionProduct) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no solution_products provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(solutionProductColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	solutionProductInsertCacheMut.RLock()
	cache, cached := solutionProductInsertCache[key]
	solutionProductInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			solutionProductAllColumns,
			solutionProductColumnsWithDefault,
			solutionProductColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(solutionProductType, solutionProductMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(solutionProductType, solutionProductMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"solution_products\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"solution_products\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into solution_products")
	}

	if !cached {
		solutionProductInsertCacheMut.Lock()
		solutionProductInsertCache[key] = cache
		solutionProductInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SolutionProduct.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SolutionProduct) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	solutionProductUpdateCacheMut.RLock()
	cache, cached := solutionProductUpdateCache[key]
	solutionProductUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			solutionProductAllColumns,
			solutionProductPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update solution_products, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"solution_products\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, solutionProductPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(solutionProductType, solutionProductMapping, append(wl, solutionProductPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update solution_products row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for solution_products")
	}

	if !cached {
		solutionProductUpdateCacheMut.Lock()
		solutionProductUpdateCache[key] = cache
		solutionProductUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q solutionProductQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for solution_products")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for solution_products")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SolutionProductSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), solutionProductPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"solution_products\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, solutionProductPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in solutionProduct slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all solutionProduct")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SolutionProduct) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no solution_products provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(solutionProductColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	solutionProductUpsertCacheMut.RLock()
	cache, cached := solutionProductUpsertCache[key]
	solutionProductUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			solutionProductAllColumns,
			solutionProductColumnsWithDefault,
			solutionProductColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			solutionProductAllColumns,
			solutionProductPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert solution_products, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(solutionProductPrimaryKeyColumns))
			copy(conflict, solutionProductPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"solution_products\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(solutionProductType, solutionProductMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(solutionProductType, solutionProductMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert solution_products")
	}

	if !cached {
		solutionProductUpsertCacheMut.Lock()
		solutionProductUpsertCache[key] = cache
		solutionProductUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SolutionProduct record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SolutionProduct) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no SolutionProduct provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), solutionProductPrimaryKeyMapping)
	sql := "DELETE FROM \"solution_products\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from solution_products")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for solution_products")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q solutionProductQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no solutionProductQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from solution_products")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for solution_products")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SolutionProductSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(solutionProductBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), solutionProductPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"solution_products\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, solutionProductPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from solutionProduct slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for solution_products")
	}

	if len(solutionProductAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SolutionProduct) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSolutionProduct(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SolutionProductSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SolutionProductSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), solutionProductPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"solution_products\".* FROM \"solution_products\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, solutionProductPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in SolutionProductSlice")
	}

	*o = slice

	return nil
}

// SolutionProductExists checks if the SolutionProduct row exists.
func SolutionProductExists(ctx context.Context, exec boil.ContextExecutor, iD []byte) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"solution_products\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if solution_products exists")
	}

	return exists, nil
}

// Exists checks if the SolutionProduct row exists.
func (o *SolutionProduct) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return SolutionProductExists(ctx, exec, o.ID)
}
